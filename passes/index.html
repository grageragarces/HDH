<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Partitioning HDHs for distribution - HDH</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Partitioning HDHs for distribution";
        var mkdocs_page_input_path = "passes.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> HDH
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../intro/">An introduction to DQC</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../hdh/">A brief introduction to HDHs</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../models/">Quantum Computational Model mappings to HDHs</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../vis/">Visualizing HDHs</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Partitioning HDHs for distribution</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#partitioning-hdhs-for-distribution">Partitioning HDHs for Distribution</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#default-cut-algorithm">Default cut algorithm</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#default-cut-algorithm_1">Default cut algorithm</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#worked-example">Worked Example</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#inputs">Inputs</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#phase-1-filling-qpu1-capacity-1-qubit">Phase 1 — Filling QPU1 (capacity: 1 qubit)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#phase-2-filling-qpu2-capacity-2-qubits">Phase 2 — Filling QPU2 (capacity: 2 qubits)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#phase-2-continued-filling-qpu3-capacity-1-qubit">Phase 2 (continued) — Filling QPU3 (capacity: 1 qubit)</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#phase-3-residual-assignment_1">Phase 3 — Residual assignment</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#metis-telegate-partitioner">METIS Telegate Partitioner</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#telegate-graph-construction">Telegate Graph Construction</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#partitioning-process">Partitioning Process</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#function-signature">Function Signature</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#kahypar-hypergraph-partitioner">KaHyPar hypergraph partitioner</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cut-cost-evaluation">Cut Cost Evaluation</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_total_cost_hdh">_total_cost_hdh</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_cut_edges_unweighted">_cut_edges_unweighted</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#helper-functions-and-internal-components">Helper Functions and Internal Components</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#temporal-incidence-frontier-utilities-greedy-partitioner">Temporal incidence + frontier utilities (greedy partitioner)</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#metis-utilities">METIS utilities</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#notes-on-evaluating-partitioners-on-random-circuits">Notes on Evaluating Partitioners on Random Circuits</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../literature/">Related publications and information</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">HDH</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Partitioning HDHs for distribution</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="hdh-partitioning-utilities">HDH Partitioning Utilities</h1>
<p>Here is an overview of the partitioning utilities available in the HDH library.</p>
<hr />
<h2 id="partitioning-hdhs-for-distribution">Partitioning HDHs for Distribution</h2>
<p>The <code>hdh/passes</code> directory contains scripts for partitioning and manipulating HDH graphs. The primary file for partitioning is <code>cut.py</code>, which offers two main approaches: a greedy, HDH-aware method and a METIS-based method operating on a qubit graph representation (telegate).</p>
<h3 id="default-cut-algorithm">Default cut algorithm</h3>
<p>The main partitioning function is <code>compute_cut</code>, which implements the <strong>Capacity-Aware Greedy HDH Partitioner</strong> in <code>cut.py</code>. </p>
<!-- ### Core mechanics

* **Node-level assignment:** individual HDH nodes like `q7_t16` are assigned, not whole logical qubits. 
* **Capacity is in unique logical qubits:** each bin tracks the set of `q` indices present; adding a node only “costs capacity” if it introduces a new logical qubit into that bin. 
* **No automatic sibling co-location:** temporal siblings of the same qubit are *not* forced into the same bin (teledata-style cuts are therefore possible).
* **Temporal validity:** candidates are expanded through a time-respecting frontier (edges “activate” at the max time of their pins). -->

<h4 id="default-cut-algorithm_1">Default cut algorithm</h4>
<p>The default capacity-aware HDH partitioning algorithm operates in three phases. </p>
<h5 id="phase-1-greedy-bin-filling-via-temporal-expansion">Phase 1: Greedy bin filling via temporal expansion</h5>
<p>The algorithm begins by selecting the earliest unassigned HDH node as a seed and opening a new bin associated with a target QPU. The bin is expanded forward in time: at each step, the algorithm identifies a frontier of unassigned nodes connected to the current bin via time-respecting HDH dependencies. From this frontier, it selects the node whose inclusion minimizes the incremental communication cost, subject to the bin's capacity constraint. Candidates that would exceed capacity are excluded.
Ties are broken in the following order: 
(1) nodes on the same qubit as the seed are preferred, 
(2) among remaining ties, earlier nodes are selected first. 
If an operation produces multiple successor nodes, each is evaluated independently.</p>
<h5 id="phase-2-sequential-bin-construction">Phase 2: Sequential bin construction</h5>
<p>Once no further admissible expansions remain (either due to capacity saturation or an exhausted frontier) the current bin is closed and the next bin is opened for the next available QPU. This repeats until all QPUs have been assigned or no unassigned nodes remain.</p>
<h5 id="phase-3-residual-assignment">Phase 3: Residual assignment</h5>
<p>If unassigned nodes remain after all bins have been instantiated, the algorithm attempts to place them in 
a best-fit procedure (assigning the next remaining node minimum incremental cost).
A node is assigned to a bin only if doing so does not introduce a new qubit beyond the bin’s remaining capacity.
Nodes that cannot be placed in any bin without violating capacity constraints are left unassigned. 
This occurs when the remaining nodes cannot be placed without exceeding the available capacity of all devices.
of a given network prior to partitioning, avoiding infeasible instances.
This phase ensures completeness of the assignment under the imposed capacity constraints.</p>
<hr />
<h3 id="worked-example">Worked Example</h3>
<p>The following walks through the greedy partitioner step by step on a small artificial computation, so you can see exactly how the three phases play out in practice.</p>
<blockquote>
<p><strong>Note on cost model:</strong> This example uses a uniform cost of 1 for all hyperedge cuts, rather than the default weighted model (quantum = 10, classical = 1). This is just to keep the numbers easy to follow — the algorithm itself is identical regardless of the cost function supplied.</p>
</blockquote>
<h4 id="inputs">Inputs</h4>
<p>The example uses a directed hypergraph representing the computational dependencies of a workload, distributed across a three-QPU network in a line topology. The QPUs have capacities of <strong>1, 2, and 1 qubit</strong> respectively. This is intentionally a tiny instance — the goal is clarity, not realism.</p>
<table>
<thead>
<tr>
<th style="text-align: center;"><img alt="Dependency hypergraph" src="../img/bigalg/input1.svg" /></th>
<th style="text-align: center;"><img alt="Three-QPU network" src="../img/bigalg/input2.svg" /></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Directed hypergraph of computational dependencies</td>
<td style="text-align: center;">Three-QPU line network with per-device capacities 1, 2, 1</td>
</tr>
</tbody>
</table>
<hr />
<h4 id="phase-1-filling-qpu1-capacity-1-qubit">Phase 1 — Filling QPU1 (capacity: 1 qubit)</h4>
<p><img alt="QPU1" src="../img/bigalg/qpu1.svg" /></p>
<p><strong>Seed:</strong> The earliest unassigned node is selected as the seed: <code>q1t1</code>.</p>
<p><img alt="Step 0" src="../img/bigalg/qpu1s0.svg" /></p>
<p><strong>Step 1:</strong> The only node reachable from <code>q1t1</code> is <code>q1t3</code>. Adding it would not introduce a new qubit (it is still qubit 1), so capacity is respected. There are no other candidates, so <code>q1t3</code> is taken.</p>
<p><img alt="Step 1" src="../img/bigalg/qpu1s1.svg" /></p>
<p><strong>Step 2:</strong> Four nodes are now connected to the QPU1 bin: <code>q1t5</code>, <code>q2t3</code>, <code>q2t4</code>, and <code>q2t5</code>. Only <code>q1t5</code> is admissible — the others all belong to qubit 2, which would bring the bin over its 1-qubit capacity. Among candidates with equal incremental cost, nodes on the same qubit as the seed are preferred, so <code>q1t5</code> would be selected even if capacity were not a constraint. We take <code>q1t5</code>.</p>
<p><img alt="Step 2" src="../img/bigalg/qpu1s2v3.svg" /></p>
<p><strong>Step 3:</strong> The remaining frontier contains <code>q2t4</code> and <code>q2t5</code>. Neither can be assigned without introducing qubit 2 into a bin already at capacity. No admissible expansion remains — the QPU1 bin is closed.</p>
<p><img alt="Step 3" src="../img/bigalg/qpu1s3.svg" /></p>
<hr />
<h4 id="phase-2-filling-qpu2-capacity-2-qubits">Phase 2 — Filling QPU2 (capacity: 2 qubits)</h4>
<p><img alt="QPU2" src="../img/bigalg/qpu2.svg" /></p>
<p><strong>Seed:</strong> The next earliest unassigned node is <code>q2t2</code>.</p>
<p><img alt="Step 0" src="../img/bigalg/qpu2s0.svg" /></p>
<p><strong>Step 1:</strong> Two nodes are reachable: <code>q1t3</code> (already assigned to QPU1) and <code>q3t3</code>. Since <code>q1t3</code> is unavailable, we take <code>q3t3</code>.</p>
<p><img alt="Step 1" src="../img/bigalg/qpu2s1v3.svg" /></p>
<p><strong>Step 2:</strong> Three candidates are now connected to the QPU2 bin: <code>q2t4</code>, <code>q3t1</code>, and <code>q4t4</code>. Adding <code>q4t4</code> would introduce a third qubit into a bin that can hold only two — it is excluded. Between <code>q2t4</code> and <code>q3t1</code>, adding <code>q3t1</code> incurs zero incremental communication cost (it is only connected to <code>q3t3</code>, which is already in this bin), so it is preferred. We take <code>q3t1</code>.</p>
<p><img alt="Step 2" src="../img/bigalg/qpu2s2.svg" /></p>
<p><strong>Step 3:</strong> The bin is now full (qubits 2 and 3). The only remaining viable candidate is <code>q2t4</code> — it belongs to qubit 2, which is already in the bin, so no new qubit is introduced. We take <code>q2t4</code>.</p>
<p><img alt="Step 3" src="../img/bigalg/qpu2s3v2.svg" /></p>
<p><strong>Step 4:</strong> Same reasoning — <code>q2t5</code> is the only viable candidate. We take it.</p>
<p><img alt="Step 4" src="../img/bigalg/qpu2s4v2.svg" /></p>
<p><strong>Step 5:</strong> The only node still connected to the QPU2 bin is <code>q3t3</code>, which is already assigned. No admissible expansion remains — the QPU2 bin is closed.</p>
<p><img alt="Step 5" src="../img/bigalg/qpu2s5v2.svg" /></p>
<hr />
<h4 id="phase-2-continued-filling-qpu3-capacity-1-qubit">Phase 2 (continued) — Filling QPU3 (capacity: 1 qubit)</h4>
<p><img alt="QPU3" src="../img/bigalg/qpu3.svg" /></p>
<p><strong>Seed:</strong> The next earliest unassigned node is <code>q4t3</code>.</p>
<p><img alt="Step 0" src="../img/bigalg/qpu3s0.svg" /></p>
<p><strong>Step 1:</strong> The only reachable node is <code>q4t5</code>, which belongs to qubit 4 — already in this bin. We take it.</p>
<p><img alt="Step 1" src="../img/bigalg/qpu3s1.svg" /></p>
<p><strong>Step 2:</strong> No further nodes are connected to the QPU3 bin. The bin is closed.</p>
<p><img alt="Step 2" src="../img/bigalg/qpu3s2.svg" /></p>
<hr />
<h4 id="phase-3-residual-assignment_1">Phase 3 — Residual assignment</h4>
<p>All nodes have been assigned by the end of Phase 2, so Phase 3 is skipped entirely.</p>
<p>The final partition assigns <code>{q1t1, q1t3, q1t5}</code> to QPU1, <code>{q2t2, q2t4, q2t5, q3t1, q3t3}</code> to QPU2, and <code>{q4t3, q4t5}</code> to QPU3 — each within the capacity of its device.</p>
<hr />
<h3 id="metis-telegate-partitioner">METIS Telegate Partitioner</h3>
<p>For an alternative partitioner, the library provides the <code>metis_telegate</code> function, which leverages the METIS algorithm (with a fallback to the Kernighan-Lin algorithm if METIS is not available) on a graph 
generated by interpreting workload qubits as nodes and operations as 
edges.</p>
<p><em>Note: this method is not capable of representing operations implemented on more than 2 states, such as Toffoli gates &amp; only interprets quantum correlations.</em></p>
<h4 id="telegate-graph-construction">Telegate Graph Construction</h4>
<ul>
<li><strong>Graph transformation:</strong> This method first converts the HDH into a "telegate" graph using the <code>telegate_hdh</code> function. In this representation:<ul>
<li><strong>Nodes</strong> are the qubits of the quantum circuit (labeled as <code>q{idx}</code>).</li>
<li><strong>Edges</strong> represent quantum operations between qubits (i.e., their co-appearance in a quantum hyperedge).</li>
<li><strong>Edge weights</strong> correspond to the multiplicity of interactions between two qubits.</li>
</ul>
</li>
<li><strong>Quantum operation filtering:</strong> Only hyperedges marked as quantum operations (with <code>tau</code> attribute = "q") are considered when building the telegate graph.</li>
</ul>
<h4 id="partitioning-process">Partitioning Process</h4>
<ul>
<li><strong>METIS partitioning:</strong> The telegate graph is partitioned using the <code>nxmetis</code> library, which provides Python bindings to the highly efficient METIS graph partitioning tool.<ul>
<li>If METIS is unavailable, the algorithm automatically falls back to the Kernighan-Lin bisection algorithm from NetworkX.</li>
<li>METIS attempts to respect capacity constraints through the <code>tpwgts</code> (target partition weights) and <code>ubvec</code> (unbalance vector) parameters.</li>
</ul>
</li>
<li><strong>Overflow repair:</strong> Since METIS does not guarantee perfectly balanced partitions, a greedy rebalancing algorithm (<code>_repair_overflow</code>) is used to adjust the partitions and ensure that no bin exceeds its qubit capacity.<ul>
<li>The repair algorithm uses a heuristic gain function (<code>_best_move_for_node</code>) to choose which qubits to move between bins.</li>
<li>It prioritizes moving qubits that minimize the increase in cut edges.</li>
</ul>
</li>
</ul>
<h4 id="function-signature">Function Signature</h4>
<pre><code class="language-python">def metis_telegate(hdh: &quot;HDH&quot;, partitions: int, capacities: int) -&gt; Tuple[List[Set[str]], int, bool, str]
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hdh</code>: The HDH graph to partition</li>
<li><code>partitions</code>: Number of partitions (k)</li>
<li><code>capacities</code>: Capacity per partition (in qubits)</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>A tuple of <code>(bins_qubits, cut_cost, respects_capacity, method)</code> where:<ul>
<li><code>bins_qubits</code> is a list of sets, each containing qubit IDs (as strings like <code>"q0"</code>, <code>"q1"</code>) in that partition</li>
<li><code>cut_cost</code> is the number of edges crossing between partitions (unweighted)</li>
<li><code>respects_capacity</code> is a boolean indicating whether all bins satisfy the capacity constraint</li>
<li><code>method</code> is either <code>"metis"</code> or <code>"kl"</code> indicating which algorithm was used</li>
</ul>
</li>
</ul>
<h3 id="kahypar-hypergraph-partitioner">KaHyPar hypergraph partitioner</h3>
<p><code>cut.py</code> also includes a KaHyPar-based partitioner, taken from the <a href="https://kahypar.org">KaHyPar library</a>.
To versions are included (qubit and node based):</p>
<p><strong><code>kahypar_cutter</code></strong></p>
<ul>
<li>Vertices are <em>logical qubits</em>.</li>
<li>Each HDH hyperedge contributes a hyperedge over the qubits that appear in it.</li>
<li>KaHyPar then runs its multilevel hypergraph partitioning pipeline (coarsening → initial partition → refinement), configured by an INI file (e.g., <code>km1_kKaHyPar_sea20.ini</code>).</li>
<li>Capacity is expressed as a <em>balance constraint</em> via KaHyPar’s <code>epsilon</code> (derived from <code>cap</code> relative to the ideal target size <code>n/k</code>). </li>
<li>This means the partitioner primarily “knows” about <strong>balancing qubit counts</strong>; it does not model HDH-specific capacity nuances (for example, heterogeneous per-QPU capacities, or time-expanded node effects), and any “capacity” notion lives inside the balance constraint.</li>
</ul>
<p><strong><code>kahypar_cutter_nodebalanced</code>:</strong></p>
<ul>
<li>Vertices are <em>HDH nodes</em> (time-expanded).</li>
<li>Balance is therefore in <strong>node count</strong>, not in unique logical qubits.</li>
<li>As a result, it can produce partitions that look well-balanced to KaHyPar but <strong>do not respect logical-qubit capacity</strong> (this is kind-off not respected by the other version either, but this one is even egregious as it doesn't know if a node would require a new active qubit in use).</li>
</ul>
<hr />
<h2 id="cut-cost-evaluation">Cut Cost Evaluation</h2>
<p>The quality of a partition is determined by the number of cut hyperedges, that is, the number of hyperedges that span across multiple QPUs (bins). The library provides two functions to evaluate this cost given a partitioning:</p>
<h3 id="_total_cost_hdh"><code>_total_cost_hdh</code></h3>
<p>Calculates the total cost of a partition on an HDH graph. This function:</p>
<ul>
<li>Iterates through all hyperedges in the HDH</li>
<li>Counts a hyperedge as "cut" if its pins (nodes) are distributed across 2 or more bins</li>
<li>Returns the sum of weights of all cut hyperedges (quantum hyperedges count as 10 and classic hyperedges count as 1 - you can modify these values in the source code but if you would like this to be adjustable please feel free to open an issue)</li>
</ul>
<h3 id="_cut_edges_unweighted"><code>_cut_edges_unweighted</code></h3>
<p>Counts the number of edges that cross between different bins in a standard graph (used for evaluating telegate graph partitions). This function:</p>
<ul>
<li>Takes a NetworkX graph and a partition assignment</li>
<li>Counts edges where the two endpoints are in different bins</li>
<li>Returns an unweighted count (each cut edge counts as 1)</li>
</ul>
<p><strong>Use case:</strong> This is specifically used by <code>metis_telegate</code> to evaluate the quality of qubit-graph partitions.</p>
<hr />
<h2 id="helper-functions-and-internal-components">Helper Functions and Internal Components</h2>
<p>The <code>cut.py</code> file contains helper utilities for the partitioners (note that some older helpers/classes remain in the file as legacy code paths).</p>
<h3 id="temporal-incidence-frontier-utilities-greedy-partitioner">Temporal incidence + frontier utilities (greedy partitioner)</h3>
<ul>
<li><code>_build_temporal_incidence</code>: builds <code>inc[node] -&gt; [(hyperedge, edge_time)]</code> and <code>pins[hyperedge] -&gt; {nodes}</code>, where <code>edge_time = max(pin_times)</code>; used to enforce temporal validity. </li>
<li><code>_push_next_valid_neighbors</code>: expands a node into the min-heap frontier, pushing only temporally valid neighbour candidates. </li>
<li><code>_select_best_from_frontier_with_rejected</code>: takes the earliest <code>beam_k</code> frontier items (skipping rejected), evaluates delta cost, and returns the best candidate. </li>
<li><code>_compute_delta_cost_simple</code>: delta in (unweighted) cut-hyperedge count if a node is added to a specific bin. </li>
<li><code>_extract_qubit_id</code>: parses <code>q{idx}_t{t}</code> to extract the logical qubit index for capacity accounting. </li>
</ul>
<h3 id="metis-utilities">METIS utilities</h3>
<ul>
<li><code>telegate_hdh</code>: converts the HDH to a qubit interaction graph (“telegate graph”). </li>
<li><code>_repair_overflow</code>, <code>_best_move_for_node</code>, <code>_over_under</code>: post-processing used to fix capacity violations after METIS/KL.</li>
<li><code>_cut_edges_unweighted</code>: unweighted cut-edge count for the telegate graph. </li>
</ul>
<hr />
<h2 id="notes-on-evaluating-partitioners-on-random-circuits">Notes on Evaluating Partitioners on Random Circuits</h2>
<p><em>We would like to warn users and partitioning strategy developers that we have found partitioners to behave very differently on real quantum workloads (such as circuits) when compared to randomly generated ones. As such, we recommend </em><em>not testing partitioners on randomly generated workloads</em><em> unless that is specifically your goal.</em></p>
<p><strong>Key considerations:</strong></p>
<ul>
<li><strong>Circuit structure matters:</strong> Real quantum algorithms often have characteristic patterns (e.g., layered structures, specific qubit interaction patterns) that random circuits lack.</li>
<li><strong>Connectivity patterns:</strong> Random circuits may not reflect the typical connectivity found in QAOA, VQE, quantum simulation, or other structured quantum algorithms.</li>
</ul>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../vis/" class="btn btn-neutral float-left" title="Visualizing HDHs"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../literature/" class="btn btn-neutral float-right" title="Related publications and information">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../vis/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../literature/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
